---
description: These rules give a top-level idea and direction while building feature for the next version of Logicflow.
alwaysApply: false
---

# Logicflow Vision & Roadmap

## Core Philosophy

Logicflow is a block-based (not node-based) visual programming environment built on the principle that **programming is operations on data**. All features, patterns, and architectural decisions must align with this functional, data-transformation paradigm.

### Key Principles

- Operations transform data from one type to another
- Real-time execution shows results inline at each step
- Type safety first—types drive the development experience
- Functional composition over imperative control flow
- Testing and debugging happen in-place, no separate mode

---

## Current State (Implemented)

### Type System

Logicflow has a complete, expressive type system supporting:

- **Primitive types**: string, number, boolean, undefined
- **Complex types**: array (with element types), object (with property types)
- **Advanced types**: union, operation, error, reference
- **Type narrowing**: Automatic type refinement based on `isTypeOf` checks

**No generics**—use concrete union types instead (e.g., `Array<string|number>`).

### Operations as First-Class Data

Operations are themselves a data type that can be:

- Passed as parameters to higher-order operations (map, filter, reduce, sort)
- Created as user-defined operations from files
- Chained after data based on first parameter type compatibility
- Stored and referenced as values

Built-in and user-defined operations appear in the same operation list.

### Control Flow

#### Conditionals

The `thenElse` operation replaces traditional if-else blocks or ternary syntax:

- Takes operation types as parameters for each branch
- Supports type narrowing based on `isTypeOf` usage
- Only executes the reachable branch (lazy evaluation)

#### Iteration

**No traditional for/while loops**—use declarative array operations:

- `map`, `filter`, `reduce`, `forEach` for transformations
- Combine with `range` for counted iterations
- Each transformation is visible in real-time

### User Experience

#### Real-time Execution

- Execute code as users build visually
- Show results inline at each operation
- Use inline errors with error boundaries per entity

#### Error Handling

- **Error type**: First-class data type (reference, type, runtime, custom)
- **Error propagation**: Errors bubble through chains without executing subsequent operations
- **Error boundaries**: Per-entity isolation prevents entire app breakage
- **No try-catch blocks**: Errors are data that can be checked using type operations

#### Block-Based Layout

Text-like linear structure (not graph-based):

- Statement-based UI with 1-to-1 correspondence to generated code
- Collapsible blocks for deep nesting
- Visual depth indicators
- Keyboard navigation with arrow keys and modifiers

#### Keyboard Navigation

Comprehensive system for efficient workflow:

- Arrow keys for navigation through statements, data, operations
- Alt + Arrow for jumping between major elements
- Cmd/Ctrl + Arrow for first/last element navigation
- Automatic focus management

### Project Structure

Projects contain:

- Multiple operation files with dependency tracking
- User-defined operations callable from other files
- Project-level variables
- Real-time execution context

---

## Next Phase (Near-Term Development)

This phase transforms Logicflow into a **complete serverless/edge function development platform**.

### Target Capability

Users should be able to visually create production-ready serverless/edge functions with:

- Full TypeScript type safety
- Asynchronous operations through promise chaining
- Deployment to multiple platforms with platform-agnostic code generation
- Native debugger with stepper and variable inspection

### 1. Asynchronous Execution Model

**Support both promise chaining and await operation**:

#### Promise Chaining

- `.then()` and `.catch()` as visible operations on promise data
- `Promise.all`, `Promise.allSettled` (after namespace support)
- Promise type: `Promise<T>` with wrapped type visible

#### Await Operation

- `.await()` operation returns an object with data or error
- Explicit async handling in visual format
- Compatible with the operations-on-data philosophy

**Promises align with our paradigm**: asynchronous operations are just another data transformation.

### 2. Code Generation and Deployment

Generate **production-ready TypeScript** with:

#### Core Output

- Proper import statements based on used packages
- Type-safe variable declarations
- Clean, readable code matching visual structure
- Environment variable references

#### Platform-Specific Templates

Create handlers for developer-focused serverless/edge platforms:

- **Supabase Edge Functions**
- **Vercel Functions**
- **Cloudflare Workers**
- **Netlify Functions**

Each template includes:

- Platform-specific handler signature
- Context object handling
- Callback vs Promise vs async handler patterns
- Proper error responses for each platform

#### Deployment Configuration

- Auto-generated package.json with dependencies
- Infrastructure-as-code files (serverless.yml, SAM templates, Terraform)
- Platform configuration files

### 3. Native Debugger

Enhance real-time execution with debugging capabilities:

- Breakpoint support at any statement
- Step-through execution mode
- Variable inspection at each step
- Execution history playback
- Performance profiling

---

## Future Vision (Long-Term)

### NPM Package Integration

This is the **killer feature** differentiating Logicflow.

#### Implementation Approach

- Users import npm packages into projects
- Extract TypeScript type definitions from `.d.ts` files automatically
- Generate visual operations from package exports
- Preserve type information for IntelliSense-like experiences

#### Entity Generation Rules

From imported packages, generate:

- Top-level functions as operations filtered by first parameter type
- Named exports as importable operations
- Object/class methods as chainable operations on that type
- Zero-parameter functions chainable from `undefined`
- Proper namespace handling for scoped operations

#### Type Safety Integration

- Use TypeScript compiler API for type inference (don't reimplement)
- Validate runtime results match expected types during development
- Extract JSDoc comments for inline documentation
- Support discriminated unions from package types

#### Security Considerations

- Sandbox npm package execution (Web Workers, isolated contexts)
- Provide "mock mode" for packages returning typed mock data
- Consider allowlist approach for untrusted packages
- Validate type definitions match runtime behavior

### Version Control Integration

Implement lightweight Git integration:

- Export/import flows as JSON for Git storage
- Visual diff for flow changes
- Branching and merging support
- Deployment versioning

### Library/Marketplace

- Share complete projects (collections of operations)
- Community-contributed operation libraries
- Template projects for common use cases
- Rating and discovery system

### Documentation Generation

Auto-generate from visual flows:

- Type signature API documentation
- Visual flow diagrams (SVG/PNG export)
- Real-time execution examples as documentation
- JSDoc integration from imported packages

### Enhanced Project Features

- Project-level constants separate from environment variables
- Cross-file dependency visualization
- Automated testing framework
- CI/CD integration

---

## What to Avoid

These patterns conflict with Logicflow's philosophy:

- **Node-based graph editors**—this is block-based, text-like
- **Traditional loops**—use functional array operations
- **Generics in type system**—unnecessary complexity for visual contexts
- **Currying/partial application**—adds complexity without value for visual contexts
- **Custom integration nodes**—leverage npm packages instead
- **Imperative control flow**—maintain functional, expression-based paradigm

---

## Development Priorities

When building features, prioritize in this order:

1. **Type system correctness**—types drive everything
2. **Real-time execution accuracy**—results must match generated code behavior
3. **Visual-to-code fidelity**—blocks must map clearly to TypeScript
4. **NPM integration robustness**—this is the differentiation factor
5. **Code generation quality**—output must be production-ready

---

## Decision Framework

When evaluating new features or approaches, ask:

1. Does this align with "operations on data" philosophy?
2. Can this be represented clearly in a block-based, linear editor?
3. Does this maintain 1-to-1 correspondence with TypeScript code?
4. Is the type system capable of representing this safely?
5. Can real-time execution show meaningful results?
6. Does this add genuine capability or just complexity?

**Core principle**: Logicflow's strength is making programming more accessible to non-developers and no-code developers without sacrificing capability—every feature should serve this goal.
